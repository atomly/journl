---
description: Rules to avoid generating code that is difficult to understand and maintain.
globs:
alwaysApply: true
---

# No AI Slop

## Code Quality Standards

### Avoid Redundant & Unnecessary Comments

- Never add verbose, redundant comments explaining obvious code
- No "helpful" comments like `// Fetch latest data from database`
- No step-by-step explanatory comments for straightforward operations
- Only add comments for complex business logic or non-obvious decisions
- Use self-documenting code with clear function and variable names

### Communication Style

- No emojis in code, comments, or documentation
- No sycophantic language like "you're absolutely right" or excessive agreement
- Be direct and factual in responses
- Focus on technical substance over pleasantries

### Code Organization

- Extract business logic into separate files by feature
- Use specific, descriptive function names that indicate purpose
- Use direct imports instead of barrel files when possible
- No monolithic functions with massive switch statements
- No code duplication - extract common patterns into helpers

### Type Safety

- NO type casting with `as` unless absolutely necessary
- NO `any` types
- Use proper TypeScript types and interfaces, prefer types over interfaces
- Let TypeScript infer types through control flow for better type safety
- Use discriminated unions and proper type guards

### Function Design

- Functions should have single, clear responsibility
- Use domain-driven naming that business stakeholders understand
- Extract helper functions to eliminate duplication
- No functions longer than ~150 lines
- No nested switch statements or complex conditional logic
- Prefer functions over arrow functions

### File Structure

- Organize by domain and feature
- Keep related functionality together
- Use clear, descriptive file names
- No barrel files unless they provide clear value
- No deeply nested directory structures

### Error Handling

- Throw meaningful errors with context
- Re-throw errors for upstream orchestration when logging errors
- No swallowing errors silently
- No generic error messages

### Import/Export Patterns

- Use direct imports for better tree-shaking
- Group imports logically: types, then modules, then utilities
- Use named exports for better tree-shaking
- Avoid default exports unless there's a single primary export

### Database Operations

- Use upsert patterns when appropriate
- Batch related operations together
- Use proper ORM patterns
- No raw SQL unless absolutely necessary

### Refactoring Guidelines

When refactoring legacy code:

1. Extract duplicate logic into helper functions first
2. Separate concerns into focused handlers
3. Replace arrays with Sets for lookups when doing membership checks
4. Remove verbose AI-generated comments
5. Use proper TypeScript types instead of casting
6. Maintain type inference through control flow

## Code Review Checklist

Before submitting code, verify:

- [ ] No redundant comments explaining obvious operations
- [ ] No type casting unless absolutely necessary
- [ ] Functions have single responsibility
- [ ] No code duplication
- [ ] Using Sets for lookups instead of arrays
- [ ] Proper TypeScript types throughout
- [ ] Clear, domain-driven naming
- [ ] No functions over ~150 lines
- [ ] Proper error handling with context

## Examples

### Bad (AI Slop)

```typescript
// Process an API event by syncing data
async function processEvent(event: APIEvent): Promise<void> {
  // Skip processing if the event isn't one we're tracking
  if (!allowedEvents.includes(event.type)) {
    console.debug(`Skipping untracked event: ${event.type}`);
    return;
  }

  // All the events we track have an ID
  const eventData = event.data.object as { id?: string };

  // ... more slop and verbose comments explaining obvious operations
}
```

### Good (Clean)

```typescript
async function handleEntityUpsertEvent(
  event: EntityCreatedEvent | EntityUpdatedEvent,
): Promise<void> {
  const entity = event.data.object;
  const timestamp = new Date();
  await upsertEntity(entity, timestamp);
}
```

Remember: Code should be self-documenting. If you need comments to explain what the code does, the code probably needs to be rewritten to be clearer.
